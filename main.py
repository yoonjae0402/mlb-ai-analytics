#!/usr/bin/env python3
"""
MLB Video Pipeline - Main Entry Point

Usage:
    python main.py --date 2024-07-04 --team Yankees
    python main.py --date 2024-07-04 --team Yankees --upload
"""

import os
import sys
import logging
import argparse
from datetime import datetime, timedelta
from pathlib import Path

# Add project root to path
sys.path.insert(0, str(Path(__file__).parent))

from src.pipeline import PipelineOrchestrator
from src.upload import YouTubeUploader

# Configure logging
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
    handlers=[
        logging.StreamHandler(),
        logging.FileHandler('logs/pipeline.log')
    ]
)

logger = logging.getLogger(__name__)

def main():
    parser = argparse.ArgumentParser(
        description='MLB Video Pipeline - Automated video generation'
    )
    
    parser.add_argument(
        '--date',
        type=str,
        help='Date to process (YYYY-MM-DD). Defaults to yesterday.',
        default=None
    )
    
    parser.add_argument(
        '--team',
        type=str,
        help='Team name (e.g., Yankees, Red Sox)',
        default='Yankees'
    )
    
    parser.add_argument(
        '--upload',
        action='store_true',
        help='Upload video to YouTube after generation'
    )
    
    parser.add_argument(
        '--dry-run',
        action='store_true',
        help='Run without uploading (for testing)'
    )
    
    args = parser.parse_args()
    
    # Determine date
    if args.date:
        date = args.date
    else:
        # Default to yesterday (games are typically processed the next day)
        yesterday = datetime.now() - timedelta(days=1)
        date = yesterday.strftime('%Y-%m-%d')
    
    logger.info("=" * 60)
    logger.info("MLB VIDEO PIPELINE")
    logger.info("=" * 60)
    logger.info(f"Date: {date}")
    logger.info(f"Team: {args.team}")
    logger.info(f"Upload: {args.upload and not args.dry_run}")
    logger.info("=" * 60)
    
    # Create necessary directories
    Path("logs").mkdir(exist_ok=True)
    Path("outputs/audio").mkdir(parents=True, exist_ok=True)
    Path("outputs/videos").mkdir(parents=True, exist_ok=True)
    
    # Initialize and run pipeline
    try:
        orchestrator = PipelineOrchestrator()
        video_path = orchestrator.run_for_date(date, args.team)
        
        if video_path:
            logger.info(f"‚úÖ SUCCESS! Video generated: {video_path}")
            
            if args.upload and not args.dry_run:
                logger.info("Uploading to YouTube...")
                try:
                    uploader = YouTubeUploader()
                    
                    # Generate title and description
                    title = f"MLB Daily Recap: {args.team} - {date}"
                    description = f"""
Daily MLB analysis and prediction for the {args.team}.

üéØ AI-Powered Predictions
üìä Data-Driven Analysis
‚öæ Professional Commentary

Generated by MLB Video Pipeline
                    """.strip()
                    
                    video_id = uploader.upload_video(
                        file_path=video_path,
                        title=title,
                        description=description,
                        tags=['MLB', 'Baseball', args.team, 'Prediction', 'Analysis'],
                        privacy_status='private'  # Start with private for safety
                    )
                    
                    if video_id:
                        logger.info(f"‚úÖ Upload successful! Video ID: {video_id}")
                    else:
                        logger.warning("Upload failed, but video was generated successfully")
                        
                except Exception as e:
                    logger.error(f"Upload error: {e}")
                    logger.info("Video was generated successfully despite upload failure")
            
            return 0
        else:
            logger.error("‚ùå FAILED: Video generation unsuccessful")
            return 1
            
    except Exception as e:
        logger.error(f"‚ùå FATAL ERROR: {e}")
        import traceback
        traceback.print_exc()
        return 1

if __name__ == "__main__":
    sys.exit(main())
